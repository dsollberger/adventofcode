---
title: "Day 12"
author: "Derek Sollberger"
format: html
---

```{r}
#| message: false
#| warning: false

library("tidyverse")

# load puzzle input
# puzzle_input <- readLines("../inputs/20221212input.txt")
puzzle_input <- readLines("../inputs/20221212example.txt")
```

```{r}
# get dimensions
M <- length(puzzle_input)
N <- nchar(puzzle_input[1])

# recreate matrix of letters
letter_mat <- matrix(rep(NA, M*N), nrow = M, ncol = N)
for(i in 1:M){
  letter_mat[i,] <- str_split(puzzle_input[i], "")[[1]]
}

# make numerical version of topography
letters_to_numbers <- match(letter_mat, letters)
topo_mat <- matrix(letters_to_numbers, nrow = M, ncol = N)
topo_mat[letter_mat == "S"] <- 1
topo_mat[letter_mat == "E"] <- 26

# create a space for puzzle solving
S_x <- which(letter_mat == "S", arr.ind = TRUE)[1]
S_y <- which(letter_mat == "S", arr.ind = TRUE)[2]
E_x <- which(letter_mat == "E", arr.ind = TRUE)[1]
E_y <- which(letter_mat == "E", arr.ind = TRUE)[2]
puzzle_mat <- matrix(rep(-1, M*N), nrow = M, ncol = N)
puzzle_mat[S_x, S_y] <- 0 # starting location
```

```{r}
# https://stackoverflow.com/questions/58123551/how-to-transform-a-data-matrix-to-a-data-frame-with-respect-to-coordinates

# xy_coords <- expand.grid(x = 1:N, y = 1:M)
# df <- transform(xy_coords, z = puzzle_mat[as.matrix(xy_coords)])

make_visual <- function(puzzle_mat, k = 1){
  df <- as.data.frame(puzzle_mat) 
  names(df) <- as.character(1:N)
  df$y <- 1:M
  df <- df |>
    pivot_longer(cols = !starts_with("y"), names_to = "x", values_to = "steps")
  
  df |>
    ggplot(aes(x = x, y = y)) +
    geom_tile(aes(fill = steps)) +
    geom_label(aes(x = x, y = y, label = steps)) +
    coord_equal() +
    labs(title = "Advent of Code, Day 12: Climbing Algorithm",
         subtitle = paste("Iteration:", k),
         caption = "Derek Sollberger") +
    scale_fill_gradient(low = "green", high = "red") +
    scale_y_reverse() +
    theme_void()
}
```

```{r}
# run maze solver
for(k in 1:(M*N)){
  for(i in 1:M){
    for(j in 1:N){
      
      # if space has already been explored, proceed to search neighbors
      if(puzzle_mat[i,j] >= 0){
        
        # look north
        if(i != 1 && puzzle_mat[i-1,j] < 0){
          if(step_mat[i-1,j] <= (step_mat[i,j] + 1)){
            puzzle_mat[i-1,j] <- puzzle_mat[i,j] + 1
          }
        }
        
        # look east
        if(j != N && puzzle_mat[i,j+1] < 0){
          if(step_mat[i,j+1] <= (step_mat[i,j] + 1)){
            puzzle_mat[i,j+1] <- puzzle_mat[i,j] + 1
          }
        }
        
        # look south
        if(i != M && puzzle_mat[i+1,j] < 0){
          if(step_mat[i+1,j] <= (step_mat[i,j] + 1)){
            puzzle_mat[i+1,j] <- puzzle_mat[i,j] + 1
          }
        }
        
        # look west
        if(j != 1 && puzzle_mat[i,j-1] < 0){
          if(step_mat[i,j-1] <= (step_mat[i,j] + 1)){
            puzzle_mat[i,j-1] <- puzzle_mat[i,j] + 1
          }
        }
        
      }
    }
  }
  
  if(puzzle_mat[E_x, E_y] > 0){
    break
  }
}

print("the fewest steps required to move from your current position")
print("to the location that should get the best signal is")
print(puzzle_mat[E_x, E_y])
```


